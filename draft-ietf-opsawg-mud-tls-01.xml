<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-ietf-opsawg-mud-tls-01" ipr="trust200902">
  <front>
    <title abbrev="MUD (D)TLS Profile for IoT devices">Manufacturer Usage
    Description (MUD) (D)TLS Profiles for IoT Devices</title>

    <author fullname="Tirumaleswar Reddy" initials="T." surname="Reddy">
      <organization abbrev="McAfee">McAfee, Inc.</organization>

      <address>
        <postal>
          <street>Embassy Golf Link Business Park</street>

          <city>Bangalore</city>

          <region>Karnataka</region>

          <code>560071</code>

          <country>India</country>
        </postal>

        <email>kondtir@gmail.com</email>
      </address>
    </author>

    <author fullname="Dan Wing" initials="D." surname="Wing">
      <organization abbrev="Citrix">Citrix Systems, Inc.</organization>

      <address>
        <postal>
          <street>4988 Great America Pkwy</street>

          <city>Santa Clara</city>

          <region>CA</region>

          <code>95054</code>

          <country>USA</country>
        </postal>

        <email>danwing@gmail.com</email>
      </address>
    </author>

    <author fullname="Blake Anderson" initials="B." surname="Anderson">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>170 West Tasman Dr</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>blake.anderson@cisco.com</email>
      </address>
    </author>

    <date />

    <workgroup>OPSAWG WG</workgroup>

    <abstract>
      <t>This memo extends the Manufacturer Usage Description (MUD)
      specification to incorporate (D)TLS profile parameters. This allows a
      network security service to identify unexpected (D)TLS usage, which can
      indicate the presence of unauthorized software or malware on an
      endpoint.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>Encryption is necessary to enhance the privacy of end users using IoT
      devices. TLS <xref target="RFC8446"></xref> and DTLS <xref
      target="I-D.ietf-tls-dtls13"></xref> are the dominant protocols
      providing encryption for IoT device traffic. Unfortunately, in
      conjunction with IoT applications' rise of encryption, malware is also
      using encryption which thwarts network-based analysis such as deep
      packet inspection (DPI). Other mechanisms are needed to detect malware
      is running on an IoT device.</t>

      <t>Malware frequently uses its own libraries for its activities, and
      those libraries are re-used much like any other software engineering
      project. <xref target="malware"></xref> indicates that there are
      observable differences in how malware uses encryption compared with how
      non-malware uses encryption. There are several interesting findings
      specific to (D)TLS which were found common to malware: <list
          style="symbols">
          <t>Older and weaker cryptographic parameters (e.g.,
          TLS_RSA_WITH_RC4_128_SHA).</t>

          <t>TLS SNI and server certificates are composed of subjects with
          characteristics of a domain generation algorithm (DGA) (e.g.,
          www.33mhwt2j.net).</t>

          <t>Higher use of self-signed certificates compared with typical
          legitimate software.</t>

          <t>Discrepancies in the server name indication (SNI) TLS extension
          in the ClientHello message and the DNS names in the
          SubjectAltName(SAN) X.509 extension in the server certificate
          message.</t>

          <t>Discrepancies in the key exchange algorithm and the client public
          key length in comparison with legitimate flows. As a reminder,
          Client Key Exchange message has been removed from TLS 1.3.</t>

          <t>Lower diversity in TLS client advertised TLS extensions compared
          to legitimate clients.</t>

          <t>Malware using privacy enhancing technologies like Tor, Psiphon
          and Ultrasurf (see <xref target="malware-tls"></xref>) and, evasion
          techniques such as ClientHello randomization to evade detection in
          order to continue exploiting the end user.</t>

          <t>Malware using DNS-over-HTTPS (DoH) <xref target="RFC8484"></xref>
          to avoid detection by malware DNS filtering service <xref
          target="malware-doh"></xref>. Malware agent may not use the DoH
          server provided by the local network. </t>
        </list></t>

      <t>If observable (D)TLS profile parameters are used, the following
      functions are possible which have a positive impact on the local network
      security:</t>

      <t><list style="symbols">
          <t>Permit intended DTLS or TLS use and block malicious DTLS or TLS
          use. This is superior to the layers 3 and 4 ACLs of Manufacturer
          Usage Description Specification (MUD) <xref target="RFC8520"></xref>
          which are not suitable for broad communication patterns.</t>

          <t>Ensure TLS certificates are valid. Several TLS deployments have
          been vulnerable to active Man-In-The-Middle (MITM) attacks because
          of the lack of certificate validation or vulnerability in the
          certificate validation function (see <xref
          target="cryto-vulnerability"></xref>). By observing (D)TLS profile
          parameters, a network element can detect when the TLS SNI mismatches
          the SubjectAltName and when the server's certificate is invalid. In
          TLS 1.2, the ClientHello, ServerHello and Certificate messages are
          all sent in clear-text, however in TLS 1.3, the Certificate message
          is encrypted thereby hiding the server identity from any
          intermediary. In TLS 1.3, the middle-box needs to act as a TLS proxy
          to validate the server certificate and to detect TLS SNI mismatch
          with the server certificate.</t>

          <t>Support new communication patterns. An IoT device can learn a new
          capability, and the new capability can change the way the IoT device
          communicates with other devices located in the local network and
          Internet. There would be an inaccurate policy if an IoT device
          rapidly changes the IP addresses and domain names it communicates
          with while the MUD ACLs were slower to update. In such a case,
          observable (D)TLS profile parameters can be used to permit intended
          use and to block malicious behavior from the IoT device.</t>
        </list></t>

      <t>This document extends MUD <xref target="RFC8520"></xref> to model
      observable (D)TLS profile parameters. Using these (D)TLS profile
      parameters, an active MUD-enforcing network security service (e.g.,
      firewall) can identify MUD non-compliant (D)TLS behavior indicating
      outdated cryptography or malware. This detection can prevent malware
      downloads, block access to malicious domains, enforce use of strong
      ciphers, stop data exfiltration, etc. In addition, organizations may
      have policies around acceptable ciphers and certificates on the websites
      the IoT devices connect to. Examples include no use of old and less
      secure versions of TLS, no use of self-signed certificates, deny-list or
      accept-list of Certificate Authorities, valid certificate expiration
      time, etc. These policies can be enforced by observing the (D)TLS
      profile parameters. Enterprise network security services can use the IoT
      device's (D)TLS profile parameters to identify legitimate flows by
      observing (D)TLS sessions, and can make inferences to permit legitimate
      flows and to block malicious or insecure flows. The proposed technique
      is also suitable in deployments where decryption techniques are not
      ideal due to privacy concerns, non-cooperating end-points, and
      expense.</t>
    </section>

    <section anchor="notation" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"></xref><xref target="RFC8174"></xref> when, and
      only when, they appear in all capitals, as shown here.</t>

      <t>"(D)TLS" is used for statements that apply to both Transport Layer
      Security <xref target="RFC8446"></xref> and Datagram Transport Layer
      Security <xref target="RFC6347"></xref>. Specific terms are used for any
      statement that applies to either protocol alone.</t>

      <t>'DoH/DoT' refers to DNS-over-HTTPS and/or DNS-over-TLS.</t>
    </section>

    <section title="Overview of MUD (D)TLS profiles for IoT devices">
      <t>In Enterprise networks, protection and detection are typically done
      both on end hosts and in the network. Host security agents have deep
      visibility on the devices where they are installed, whereas the network
      has broader visibility. Installing host agents may not be a viable
      option on IoT devices, and network-based security is an efficient means
      to protect such IoT devices. If the IoT device supports MUD (D)TLS
      profile, the (D)TLS profile parameters of the IoT device can be used by
      middleboxes to detect and block malware communication, while at the same
      time preserving the privacy of legitimate uses of encryption.
      Middleboxes need not proxy (D)TLS but can passively observe the
      parameters of (D)TLS handshakes from IoT devices and gain good
      visibility into TLS 1.2 parameters and partial visibility into TLS 1.3
      parameters. Malicious agents can try to use the (D)TLS profile
      parameters of legitimate agents to evade detection, but it becomes a
      challenge to mimic the behavior of various IoT device types and IoT
      device models from several manufacturers. In other words, malware
      developers will have to develop malicious agents per IoT device type,
      manufacturer and model, infect the device with the tailored malware
      agent and will have keep up with updates to the device's (D)TLS profile
      parameters over time. Further, the malware's command and control server
      certificates need to be signed by the same certifying authorities
      trusted by the IoT devices. Typically, IoT devices have an
      infrastructure that supports a rapid deployment of updates, and malware
      agents will have a near-impossible task of similarly deploying updates
      and continuing to mimic the TLS behavior of the IoT device it has
      infected. However, if the IoT device has reached end-of-life and the IoT
      manufcaturer will not issue a firmware or software update to the Thing
      or will not update the MUD file, the "is-supported" attribute defined in
      Section 3.6 of <xref target="RFC8520"></xref> can be used by the MUD
      manager to identify the IoT manufcaturer no longer supports the device.
      The end-of-life of a device does not necessarily mean that it is
      defective; rather, it denotes a need to replace and upgrade the network
      to next-generation devices for additional functionality. The network
      security service will have to rely on other techniques discussed in
      <xref target="Security"></xref> to identify malicious flows until the
      device is replaced.</t>

      <t>Compromised IoT devices are typically used for launching DDoS attacks
      (Section 3 of <xref target="RFC8576"></xref>). For example, DDoS attacks
      like Slowloris and Transport Layer Security (TLS) re-negotiation can be
      blocked if the victim's server certificate is not be signed by the same
      certifying authorities trusted by the IoT device.</t>
    </section>

    <section title="(D)TLS 1.3 Handshake">
      <t>In (D)TLS 1.3, full (D)TLS handshake inspection is not possible since
      all (D)TLS handshake messages excluding the ClientHello message are
      encrypted. (D)TLS 1.3 has introduced new extensions in the handshake
      record layers called Encrypted Extensions. Using these extensions
      handshake messages will be encrypted and network security services (such
      as a firewall) are incapable to decipher the handshake, and thus cannot
      view the server certificate. However, the ClientHello and ServerHello
      still have some fields visible, such as the list of supported versions,
      named groups, cipher suites, signature algorithms and extensions in
      ClientHello and, chosen cipher in the ServerHello. For instance, if the
      malware uses evasion techniques like ClientHello randomization, the
      observable list of cipher suites and extensions offered by the malware
      agent in the ClientHello message will not match the list of cipher
      suites and extensions offered by the legitimate client in the
      ClientHello message, and the middlebox can block malicious flows without
      acting as a (D)TLS 1.3 proxy.</t>

      <section title="Full (D)TLS 1.3 Handshake Inspection">
        <t>To obtain more visibility into negotiated TLS 1.3 parameters, a
        middlebox can act as a (D)TLS 1.3 proxy. A middlebox can act as a
        (D)TLS proxy for the IoT devices owned and managed by the IT team in
        the Enterprise network and the (D)TLS proxy must meet the security and
        privacy requirements of the organization. In other words, the scope of
        middlebox acting as a (D)TLS proxy is restricted to Enterprise network
        owning and managing the IoT devices. The middlebox would have to
        follow the behaviour detailed in Section 9.3 of <xref
        target="RFC8446"></xref> to act as a compliant (D)TLS 1.3 proxy.</t>

        <t>To further increase privacy, encrypted client hello <xref
        target="I-D.ietf-tls-esni"></xref> prevents passive observation of the
        TLS Server Name Indication extension. To effectively provide that
        privacy protection, SNI encryption needs to be used in conjunction
        with DNS encryption (e.g., DoH). A middlebox (e.g., firewall)
        passively inspecting an encrypted SNI (D)TLS handshake cannot observe
        the encrypted SNI nor observe the encrypted DNS traffic.</t>
      </section>

      <section title="Encrypted DNS">
        <t>A common usage pattern for certain type of IoT devices (e.g., light
        bulb) is for it to "call home" to a service that resides on the public
        Internet, where that service is referenced through a domain name (A or
        AAAA record). As discussed in Manufacturer Usage Description
        Specification <xref target="RFC8520"></xref>, because these devices
        tend to require access to very few sites, all other access should be
        considered suspect. If an IoT device is pre-configured to use public
        DoH/DoT server, the MUD policy enforcement point is moved to that
        public server, which cannot enforce the MUD policy based on domain
        names (Section 8 of <xref target="RFC8520"></xref>). If the DNS query
        is not accessible for inspection, it becomes quite difficult for the
        infrastructure to suspect anything. Thus the use of a public DoH/DoT
        server is incompatible with MUD in general. A local DoH/DoT server is
        necessary to allow MUD policy enforcement on the local network <xref
        target="I-D.reddy-add-enterprise"></xref>.</t>
      </section>
    </section>

    <section anchor="YANG" title="(D)TLS Profile YANG Module">
      <t>This document specifies a YANG module for representing (D)TLS
      profile. The (D)TLS profile YANG module provides a method for network
      security services to observe the (D)TLS profile parameters in the (D)TLS
      handshake to permit intended use and to block malicious behavior. This
      module uses the common YANG types defined in <xref
      target="RFC6991"></xref>, the rules defined in <xref
      target="RFC8519"></xref>, and the cryptographic types defined in <xref
      target="I-D.ietf-netconf-crypto-types"></xref>. See <xref
      target="RFC7925"></xref> for TLS 1.2 and <xref
      target="I-D.ietf-uta-tls13-iot-profile"></xref> for TLS 1.3
      recommandates related to IoT devices.</t>

      <t>The (D)TLS parameters in each (D)TLS profile include the
      following:<list style="symbols">
          <t>Profile name</t>

          <t>(D)TLS versions supported by the IoT device.</t>

          <t>List of supported symmetric encryption algorithms. As a reminder,
          TLS 1.3 defines five cipher suites (Appendix B.4 of <xref
          target="RFC8446"></xref>), but most clients are continuing to offer
          TLS 1.2 compatible cipher suites for backwards compatibility.</t>

          <t>List of supported compression methods for data compression. In
          TLS 1.3, only the "null" compression method is allowed (Section
          4.1.2 of <xref target="RFC8446"></xref>).</t>

          <t>List of supported extension types</t>

          <t>List of trust anchor certificates used by the IoT device. If the
          server certificate is signed by one of the trust anchors, the
          middlebox continues with the connection as normal. Otherwise, the
          middlebox will react as if the server certificate validation has
          failed and takes appropriate action (e.g, block the (D)TLS session).
          An IoT device can use a private trust anchor to validate a server's
          certificate (e.g., the private trust anchor can be preloaded at
          manufacturing time on the IoT device and the IoT device fetches the
          firmware image from the Firmware server whose certificate is signed
          by the private CA).</t>

          <t>List of SPKI pin set pre-configured on the client to validate
          self-signed server certificates or raw public keys. A SPKI pin set
          is a cryptographic digest to "pin" public key information in a
          manner similar to HTTP Public Key Pinning (HPKP) <xref
          target="RFC7469"></xref>. If SPKI pin set is present in the (D)TLS
          profile of a IoT device and the server certificate does not pass the
          PKIX certification path validation, the middlebox computes the SPKI
          Fingerprint for the public key found in the server's certificate (or
          in the raw public key, if the server provides that instead). If a
          computed fingerprint exactly matches one of the SPKI pin sets in the
          (D)TLS profile, the middlebox continues with the connection as
          normal. Otherwise, the middlebox will act on the SPKI validation
          failure and takes appropriate action.</t>

          <t>Cryptographic hash algorithm used to generate the SPKI
          pinsets</t>

          <t>List of pre-shared key exchange modes</t>

          <t>List of named groups (DHE or ECDHE) supported by the client</t>

          <t>List signature algorithms the client can validate in X.509 server
          certificates</t>

          <t>List signature algorithms the client is willing to accept for
          CertificateVerify message (Section 4.2.3 of <xref
          target="RFC8446"></xref>). For example, a TLS client implementation
          can support different sets of algorithms for certificates and in TLS
          to signal the capabilities in "signature_algorithms_cert" and
          "signature_algorithms" extensions.</t>

          <t>List of supported application protocols (e.g., h3, h2, http/1.1
          etc.)</t>

          <t>List of certificate compression algorithms (defined in <xref
          target="I-D.ietf-tls-certificate-compression"></xref>)</t>

          <t>List of the distinguished names <xref target="X501"></xref> of
          acceptable certificate authorities, represented in DER-encoded
          format <xref target="X690"> </xref> (defined in Section 4.2.4 of
          <xref target="RFC8446"></xref>)</t>

          <t>List of client key exchange algorithms and the client public key
          lengths in (D)TLS 1.2</t>
        </list></t>

      <t><xref target="RFC8701">GREASE</xref> sends random values on TLS
      parameters to ensure future extensibility of TLS extensions. Such GREASE
      values might be extended to other TLS parameters. Thus, the (D)TLS
      profile parameters defined in the YANG module by this document MUST NOT
      include the GREASE values for extension types, named groups, signature
      algorithms, (D)TLS versions, pre-shared key exchange modes, cipher
      suites and for any other TLS parameters defined in future RFCs.</t>

      <t>Note: The TLS and DTLS IANA registries are available from <eref
      target="https://www.iana.org/assignments/tls-parameters/tls-parameters.txt"></eref>
      and <eref
      target="https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.txt"></eref>.
      The values for all the parameters in the YANG module excluding the
      supported_versions parameter are defined in the TLS and DTLS IANA
      registries. The TLS and DTLS IANA registry does not maintain (D)TLS
      version numbers.</t>

      <section title="Tree Structure">
        <t>This document augments the "ietf-mud" MUD YANG module defined in
        <xref target="RFC8520"></xref> for signaling the IoT device (D)TLS
        profile. This document defines the YANG module
        "iana-opsawg-mud-tls-profile", which has the following tree
        structure:</t>

        <t><figure>
            <artwork><![CDATA[
module: iana-opsawg-mud-tls-profile
  augment /acl:acls/acl:acl/acl:aces/acl:ace/acl:matches:
    +--rw client-profile
       +--rw tls-dtls-profiles* [profile-name]
          +--rw profile-name                   string
          +--rw supported_tls_versions*        tls-version
          +--rw supported_dtls_versions*       dtls-version
          +--rw encryption-algorithms*         encryption-algorithm
          +--rw compression-methods*           compression-method
          +--rw extension-types*               extension-type
          +--rw acceptlist-ta-certs*           ct:trust-anchor-cert-cms
          +--rw SPKI-pin-sets*                 SPKI-pin-set
          +--rw SPKI-hash-algorithm?           iha:hash-algorithm-type
          +--rw psk-key-exchange-modes*        psk-key-exchange-mode
          +--rw supported-groups*              supported-group
          +--rw signature-algorithms-cert*     signature-algorithm {tls-1_3 or dtls-1_3}?
          +--rw signature-algorithms*          signature-algorithm
          +--rw application-protocols*         application-protocol
          +--rw cert-compression-algorithms*   cert-compression-algorithm
          +--rw client-public-keys {tls-1_2 or dtls-1_2}?
             +--rw key-exchange-algorithms*     key-exchange-algorithm
             +--rw client-public-key-lengths*   client-public-key-length


]]></artwork>
          </figure></t>
      </section>

      <section title="YANG Module">
        <t><figure>
            <artwork><![CDATA[module iana-opsawg-mud-tls-profile {
   yang-version 1.1;
   namespace "urn:ietf:params:xml:ns:yang:iana-opsawg-mud-tls-profile";
   prefix mud-tls-profile;


   import ietf-crypto-types {
     prefix ct;
     reference "draft-ietf-netconf-crypto-types-01: 
                Common YANG Data Types for Cryptography";
   }

   import iana-hash-algs {
     prefix iha;
     reference
          "RFC XXXX: Common YANG Data Types for Hash algorithms";
   }

   import ietf-access-control-list {
     prefix acl;
     reference
       "RFC 8519: YANG Data Model for Network Access
                  Control Lists (ACLs)";
   }

   organization
     "IETF Operations and Management Area Working Group Working Group";
   contact
      "Editor:  Konda, Tirumaleswar Reddy
               <mailto:TirumaleswarReddy_Konda@McAfee.com>";

   description
     "This module contains YANG definition for the IoT device
      (D)TLS profile.

      Copyright (c) 2019 IETF Trust and the persons identified as
      authors of the code.  All rights reserved.

      Redistribution and use in source and binary forms, with or
      without modification, is permitted pursuant to, and subject
      to the license terms contained in, the Simplified BSD License
      set forth in Section 4.c of the IETF Trust's Legal Provisions
      Relating to IETF Documents
      (http://trustee.ietf.org/license-info).

      This version of this YANG module is part of RFC XXXX; see
      the RFC itself for full legal notices.";

   revision 2019-06-12 {
     description
       "Initial revision";
   }

   typedef compression-method {
     type uint8;
     description "Compression method";
   }

   typedef extension-type {
     type uint16;
     description "Extension type";
   }

   typedef encryption-algorithm {
     type uint16;
     description "Encryption algorithm";
   }

   typedef supported-group {
     type uint16;
     description "Named group (DHE or ECDHE)";
   }

   typedef SPKI-pin-set {
     type binary;
     description "Subject Public Key Info pin set";
   }

   typedef signature-algorithm {
     type uint16;
     description "Signature algorithm";
   }

   typedef key-exchange-algorithm {
     type uint8;
     description "key exchange algorithm";
   }

   typedef psk-key-exchange-mode {
     type uint8;
     description "pre-shared key exchange mode";
   }

   typedef client-public-key-length {
     type uint8;
     description "client public key length";
   }

   typedef application-protocol {
     type string;
     description "application protocol";
   }

   typedef cert-compression-algorithm {
     type uint8;
     description "certificate compression algorithm";
   }

   typedef certificate_authority {
     type binary;
     description "Distinguished Name of Certificate authority";
   }

   typedef tls-version {
       type enumeration {
         enum tls-1.2 {
           value 1;
           description
               "TLS Protocol Version 1.2.";
           reference
              "RFC 5246: The Transport Layer Security (TLS) Protocol
                                   Version 1.2";
         }
         enum tls-1.3 {
           value 2;
           description
               "TLS Protocol Version 1.3.";
           reference
              "RFC 8446: The Transport Layer Security (TLS) Protocol
                                   Version 1.3";
         }
      }
      description
           "Indicates the TLS version.";
   }

   typedef dtls-version {
     type enumeration {
         enum dtls-1.2 {
           value 1;
           description
               "DTLS Protocol Version 1.2.";
           reference
              "RFC 6346: Datagram Transport Layer Security 1.2";
         }
         enum dtls-1.3 {
           value 2;
           description
               "DTLS Protocol Version 1.3.";
           reference
               "draft-ietf-tls-dtls13: Datagram Transport Layer Security 1.3";
         }
     }
     description
       "Indicates the DTLS version.";
   }

   feature tls-1_2 {
     description
       "TLS Protocol Version 1.2 is supported.";
       reference
         "RFC 5246: The Transport Layer Security (TLS) Protocol
                    Version 1.2";
   }

   feature tls-1_3 {
     description
       "TLS Protocol Version 1.3 is supported.";
       reference
         "RFC 8446: The Transport Layer Security (TLS) Protocol
                    Version 1.3";
   }

   feature dtls-1_2 {
       description
          "DTLS Protocol Version 1.2 is supported.";
       reference
          "RFC 6346: Datagram Transport Layer Security Version 1.2";
   }

   feature dtls-1_3 {
       description
         "DTLS Protocol Version 1.3 is supported.";
       reference
         "draft-ietf-tls-dtls13: Datagram Transport Layer Security 1.3";
   }

   grouping client-profile {
     description
       "A grouping for (D)TLS profiles."; 
     container client-profile {
       list tls-dtls-profiles {
         key "profile-name";
         description
          "A list of (D)TLS version profiles supported by the client.";
        leaf profile-name {
          type string {
            length "1..64";
          }
          description
            "The name of (D)TLS profile; space and special
            characters are not allowed.";
         }
         leaf-list supported_versions {
           type uint16;
           description 
             "(D)TLS versions supported by the client";
         }  
         leaf-list encryption-algorithms {
           type encryption-algorithm;   
           description "Encryption algorithms";
         }
         leaf-list compression-methods {
           type compression-method;
            description "Compression methods";
         } 
         leaf-list extension-types {
           type extension-type;
           description "Extension Types";
         }
         leaf-list acceptlist-ta-certs { 
           type ct:trust-anchor-cert-cms;
           description 
             "A list of trust anchor certificates used by the client.";
         }
         leaf-list SPKI-pin-sets { 
            type SPKI-pin-set;
            description 
             "A list of SPKI pin sets pre-configured on the client 
              to validate self-signed server certificate or 
              raw public key.";
         }
         leaf SPKI-hash-algorithm {
           type iha:hash-algorithm-type;
           description 
             "cryptographic hash algorithm used to generate the 
              SPKI pinset.";
         }
         leaf-list psk-key-exchange-modes {
           type psk-key-exchange-mode;
           description 
             "pre-shared key exchange modes";
         }
         leaf-list supported-groups { 
            type supported-group;
            description 
             "A list of named groups supported by the client.";
         }
         leaf-list signature-algorithms-cert { 
            type signature-algorithm;
            description 
             "A list signature algorithms the client can validate 
              in X.509 certificates.";
         }
         leaf-list signature-algorithms { 
            type signature-algorithm;
            description 
             "A list signature algorithms the client can validate 
              in the CertificateVerify message.";
         }
         leaf-list application-protocols { 
            type application-protocol;
            description 
             "A list application protocols supported by the client";
         }
         leaf-list cert-compression-algorithms { 
            type cert-compression-algorithm;
            description 
             "A list certificate compression algorithms 
              supported by the client";
         }
         leaf-list certificate_authorities { 
            type certificate_authority;
            description 
             "A list of the distinguished names of certificate authorities 
              acceptable to the client";
         }
         container client-public-keys {
           if-feature "tls-1_2 or dtls-1_2"; 
           leaf-list key-exchange-algorithms {
             type key-exchange-algorithm; 
             description
             "Key exchange algorithms supported by the client";
           }
           leaf-list client-public-key-lengths {
             type client-public-key-length; 
             description
             "client public key lengths";
           }
         }
   }
  }   
 }
 augment "/acl:acls/acl:acl/acl:aces/acl:ace/acl:matches" {
   description
     "MUD (D)TLS specific matches.";
   uses client-profile;
 }
}
]]></artwork>
          </figure></t>
      </section>
    </section>

    <section anchor="processing" title="Processing of the MUD (D)TLS Profile">
      <t>The following text outlines the rules for a network security service
      (e.g., firewall) to follow to process the MUD (D)TLS Profile:</t>

      <t><list style="symbols">
          <t>If the (D)TLS profile parameter observed in a (D)TLS session is
          specified in the MUD (D)TLS profile but its corresponding value is
          not specified in the MUD (D)TLS profile, and if the (D)TLS parameter
          value is recognized by the firewall, it can identify unexpected
          (D)TLS usage, which can indicate the presence of unauthorized
          software or malware on an endpoint. The firewall can take several
          actions like block the (D)TLS session or raise an alert to
          quarantine and remediate the compromised device. </t>

          <t>If the (D)TLS parameter and/or its corresponding value observed
          in a (D)TLS session is not specified in the MUD (D)TLS profile, and
          if the (D)TLS parameter and/or its corresponding value is not
          recognized by the firewall, it can ignore unrecognized parameter
          and/or its corresponding value and the correct behavior is not to
          block the (D)TLS session. The behaviour is functionally equivalent
          to the description in Section 9.3 of <xref target="RFC8446"></xref>
          to ignore all unrecognized cipher suites, extensions, and other
          parameters. </t>

          <t>Deployments update at different rates, so an updated MUD (D)TLS
          profile may support newer parameters and corresponding values. If
          the firewall does not recognize the newer parameters and associated
          values, an alert should be triggered to the firewall vendor and the
          IoT device owner or administrator. A firewall must be readily
          updatable, so that when ossification problems are discovered, they
          can be addressed quickly. Most importantly, if the firewall is not
          readily updatable, its efficacy to identify emerging malware will
          decrease with time. </t>
        </list></t>
    </section>

    <section anchor="Example" title="MUD File Example">
      <t>The example below contains (D)TLS profile parameters for a IoT device
      used to reach servers listening on port 443 using TCP transport. JSON
      encoding of YANG modelled data <xref target="RFC7951"></xref> is used to
      illustrate the example.</t>

      <t><figure>
          <artwork><![CDATA[{
   "ietf-mud:mud": {
     "mud-version": 1,
      "mud-url": "https://example.com/IoTDevice",
      "last-update": "2019-18-06T03:56:40.105+10:00",
      "cache-validity": 100,
      "is-supported": true,
      "systeminfo": "IoT device name",
      "from-device-policy": {
         "access-lists": {
           "access-list": [
             {
               "name": "mud-7500-profile"
             }
           ]
         }
      },
     "ietf-access-control-list:acls": {
       "acl": [
         {
           "name": "mud-7500-profile",
           "type": "ipv6-acl-type",
           "aces": {
             "ace": [
               {
                 "name": "cl0-frdev",
                 "matches": {
                   "ipv6": {
                     "protocol": 6
                   },
                   "tcp": {
                     "ietf-mud:direction-initiated": "from-device",
                     "destination-port": {
                       "operator": "eq",
                       "port": 443
                     }
                   },
                   "iana-opsawg-mud-tls-profile:client-profile" : {
                     "tls-dtls-profiles" : [
                        {
                           "supported-tls-versions" : [1],
                           "encryption-algorithms" : 
                              [31354, 4865, 4866, 4867],  
                           "extension-types" : [10,11,13,16,24],  
                           "supported-groups" : [29]
                        } 
                      ]
                   },
                   "actions": {
                      "forwarding": "accept"
                   }
               }
            }
          ]
         }
        }
       ]
     }
   }
}
]]></artwork>
        </figure></t>

      <t>The following illustrates the example sceanios for processing the
      above profile:<list style="symbols">
          <t>If the extension type observed in a TLS session includes
          "encrypt_then_mac" (code point 22) <xref target="RFC7366"></xref> in
          the ClientHello message, and if the extension encrypt_then_mac is
          recognized by the firewall, it can identify unexpected TLS
          usage.</t>

          <t>If the extension type observed in a TLS session includes
          "token_binding" (code point 24) <xref target="RFC8472"></xref> in
          the ClientHello message, and if the extension token_binding is not
          recognized by the firewall, it can ignore the unrecognized
          extension. Because the extension type token_binding is specified in
          the profile, an alert will be triggered to the firewall vendor and
          the IoT device owner or administrator to notify the firewall is not
          up to date.</t>
        </list></t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Security considerations in <xref target="RFC8520"></xref> need to be
      taken into consideration. Although it is challenging for a malware to
      mimic the TLS behavior of various IoT device types and IoT device models
      from several manufacturers, malicious agents have a very low probability
      of using the same (D)TLS profile parameters as legitimate agents on the
      IoT device to evade detection. Network security services should also
      rely on contextual network data to detect false negatives. In order to
      detect such malicious flows, anomaly detection (deep learning techniques
      on network data) can be used to detect malicious agents using the same
      (D)TLS profile parameters as legitimate agent on the IoT device. In
      anomaly detection, the main idea is to maintain rigorous learning of
      "normal" behavior and where an "anomaly" (or an attack) is identified
      and categorized based on the knowledge about the normal behavior and a
      deviation from this normal behavior.</t>
    </section>

    <section anchor="Privacy" title="Privacy Considerations">
      <t>Privacy considerations discussed in Section 16 of <xref
      target="RFC8520"></xref> to not reveal the MUD URL to an atacker need to
      be taken into consideration. The MUD URL can be stored in Trusted
      Execution Environment (TEE) for for secure operation, enhanced data
      security and to prevent exposure to an unauthorized software. </t>

      <t>The middlebox acting as a (D)TLS proxy must immediately delete the
      decrypted data upon completing any necessary inspection functions. TLS
      proxy potentially has access to a user's PII (Personally identifiable
      information) and PHI (Protected Health Information). The TLS proxy must
      not store, process or modify PII data. For example, IT administrator can
      configure the middlebox to bypass payload inspection for a connection
      destined to a specific service due to privacy compliance requirements.
      In addition, mechanisms based on object security can be used by IoT
      devices to enable end-to-end security and the middlebox will not have
      any access to the packet data. For example, Object Security for
      Constrained RESTful Environments (OSCORE) <xref target="RFC8613"></xref>
      is a proposal that protects CoAP messages by wrapping them in the COSE
      format <xref target="RFC8152"></xref>.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>Each normative YANG module MUST be registered in both the "IETF XML
      Registry" <xref target="RFC3688"></xref> and the "YANG Module Names"
      registry <xref target="RFC6020"></xref>.</t>

      <t>This document requests IANA to register the following URIs in the
      "ns" subregistry within the "IETF XML Registry" <xref
      target="RFC3688"></xref>: <figure>
          <artwork><![CDATA[      URI: urn:ietf:params:xml:ns:yang:iana-opsawg-mud-tls-profile
      Registrant Contact: The IESG.
      XML: N/A; the requested URI is an XML namespace.
]]></artwork>
        </figure></t>

      <t>This document requests IANA to register the following YANG modules in
      the "YANG Module Names" subregistry [RFC6020] within the "YANG
      Parameters" registry. IANA is requested to create an IANA-maintained
      YANG Module called "iana-opsawg-mud-tls-profile", based on the contents
      of Section 5, which will allow for new (D)TLS parameters and (D)TLS
      versions. The registration procedure will be Expert Review or
      Specification Required, as defined by <xref
      target="RFC8126"></xref>.</t>

      <t><figure>
          <artwork><![CDATA[      name: iana-opsawg-mud-tls-profile
      namespace: urn:ietf:params:xml:ns:yang:iana-opsawg-mud-tls-profile
      maintained by IANA: Y
      prefix: mud-tls-profile
      reference: RFC XXXX
]]></artwork>
        </figure></t>
    </section>

    <section anchor="acknowledgments" title="Acknowledgments">
      <t>Thanks to Flemming Andreasen, Shashank Jain, Michael Richardson,
      Piyush Joshi and Harsha Joshi for the discussion and comments.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>

      <?rfc include='reference.RFC.8174'?>

      <?rfc include="reference.RFC.6991"?>

      <?rfc include="reference.RFC.8446"?>

      <?rfc include="reference.RFC.6347"?>

      <?rfc include="reference.RFC.8519"?>

      <?rfc include='reference.RFC.3688'?>

      <?rfc include='reference.RFC.8701'?>

      <?rfc include="reference.I-D.ietf-tls-dtls13" ?>

      <?rfc include="reference.I-D.ietf-netconf-crypto-types"  ?>

      <?rfc include="reference.I-D.ietf-tls-certificate-compression"?>

      <reference anchor="X690">
        <front>
          <title>Information technology - ASN.1 encoding Rules: Specification
          of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and
          Distinguished Encoding Rules (DER)</title>

          <author>
            <organization>ITU-T</organization>
          </author>

          <date year="2002" />
        </front>

        <seriesInfo name="ISO/IEC" value="8825-1:2002" />
      </reference>
    </references>

    <references title="Informative References">
      <?rfc include='reference.RFC.8520'?>

      <?rfc include='reference.RFC.7951'?>

      <?rfc include="reference.RFC.7469"?>

      <?rfc include="reference.RFC.8576"?>

      <?rfc include="reference.RFC.8484"?>

      <?rfc include="reference.RFC.6020"?>

      <?rfc include="reference.RFC.8152"
?>

      <?rfc include='reference.RFC.8126'?>

      <?rfc include='reference.RFC.8613'?>

      <?rfc include='reference.RFC.7925'?>

      <?rfc include='reference.RFC.7366'?>

      <?rfc include='reference.RFC.8472'?>

      <?rfc include="reference.I-D.ietf-tls-esni" ?>

      <?rfc include="reference.I-D.ietf-uta-tls13-iot-profile" 
?>

      <?rfc include='reference.I-D.reddy-add-enterprise'?>

      <!--      <?rfc include='reference.I-D.ietf-dnsop-svcb-https' ?> -->

      <reference anchor="malware" target="https://arxiv.org/abs/1607.01639">
        <front>
          <title>Deciphering Malware&rsquo;s use of TLS (without
          Decryption)</title>

          <author fullname="Blake Anderson" initials="B." surname="Anderson">
            <organization>Cisco</organization>
          </author>

          <author fullname="Subharthi Paul" initials="S." surname="Paul">
            <organization>Cisco</organization>
          </author>

          <author fullname="David McGrew" initials="D." surname="McGrew">
            <organization>Cisco</organization>
          </author>

          <date month="July" year="2016" />
        </front>
      </reference>

      <reference anchor="X501">
        <front>
          <title>Information Technology - Open Systems Interconnection - The
          Directory: Models</title>

          <author>
            <organization></organization>
          </author>

          <date year="1993" />
        </front>

        <seriesInfo name="ITU-T" value="X.501" />
      </reference>

      <reference anchor="malware-tls"
                 target="https://dl.acm.org/citation.cfm?id=3355601">
        <front>
          <title>TLS Beyond the Browser: Combining End Host and Network Data
          to Understand Application Behavior</title>

          <author fullname="Blake Anderson" initials="B." surname="Anderson">
            <organization>Cisco</organization>
          </author>

          <author fullname="David McGrew" initials="D." surname="McGrew">
            <organization>Cisco</organization>
          </author>

          <date month="October" year="2019" />
        </front>
      </reference>

      <reference anchor="cryto-vulnerability"
                 target="https://media.defense.gov/2020/Jan/14/2002234275/-1/-1/0/CSA-WINDOWS-10-CRYPT-LIB-20190114.PDF">
        <front>
          <title>Exploiting the Windows CryptoAPI Vulnerability</title>

          <author fullname="Ben Perez" initials="B." surname="Perez">
            <organization>Cisco</organization>
          </author>

          <date month="January" year="2020" />
        </front>
      </reference>

      <reference anchor="malware-doh"
                 target="https://www.zdnet.com/article/first-ever-malware-strain-spotted-abusing-new-doh-dns-over-https-protocol/">
        <front>
          <title>First-ever malware strain spotted abusing new DoH (DNS over
          HTTPS) protocol</title>

          <author fullname="Catalin Cimpanu" initials="C." surname="Cimpanu">
            <organization>Cisco</organization>
          </author>

          <date month="July" year="2019" />
        </front>
      </reference>
    </references>
  </back>
</rfc>
